# Вот у нас есть два списка:
#
# a = [1, 2, 3, 4, 5]
#
# b = [100, 200, 300, 400, 500]
#
# Нам нужно вывести в одну строчку пару с двух списков которые стоят на одинаковы индексах, тоесть индекс начинается с 0.
#
# В списке а под нулевым индексом стоит -  1, а в списке б – 100
#
# Нам нужно так вывести все пары каждую на отдельной строчке и это можно сделать циклов for
#
# for i in range(len(a)): – указываем в range() длину списка а(можно и b но нет разницы у них одинаковая длина)
#
#          print(a[i], b[i]) – range(len(a)) – выдаст 5 элементов – 0,1,2,3,4 а эти числа совпадают с индексами элементов двух списков и если указать переменную i В которой по очередно будут поступать числа от 0 до 4 то мы можем вывести в обоих списках по одному элементу начания с нулевого индекса
#
# Вывод: 1 100
#
#     2 200
#
#     3 300
#
#    4 400
#
#    5 500
#
# Мы получили то что нам нужно но этот код можно заменить одной функцией zip:
#
# zip() принимает аргументами несколько итерабельных последовательностей(tuple, list) и выводит их элементы стоящие на одном индексе парно каждую в отдельной строке:
#
# print(zip(a, b)) – первым аргументом мы передали список а, вторым передали список б.
#
# Данное выражение вернет нам zip Обьект: <zip object at 0x02C0A488>
#
# Zip обьект является итератором а как мы знаем итератор можно превратить в итерабельную последовательность например кортеж(tuple):
#
#  print(tuple(zip(a, b))) – данный код выведет нам пары в одну строчку но так как на нужно вывести их каждую в отдельной строке сделаем так:
#
# print(*tuple(zip(a, b)), sep='\n') – тут мы передаем парамет sep=’\n’
#
# который является параметров функции print() в параметре sep`а мы указали \n тоесть переходи на следующую строку, и так после каждого вывода новой пары мы будем переходить на следующую строку, а ‘*’в начален принта убирает запятые.
#
# Вывод:
#
# (1, 100)
#
# (2, 200)
#
# (3, 300)
#
# (4, 400)
#
# (5, 500)
#
# Как видите все работает.
#
# Также можно добавить третий аргумент.
#
# c = ‘abcde’ – переменная ‘c’ с строкой
#
# Далее делаем все тоже самое:
#
# print(*tuple(zip(a, b, c)), sep='\n') – просто добавляем переменную с как третий аргумент.
#
# Вывод:
#
# (1, 100, 'a')
#
# (2, 200, 'b')
#
# (3, 300, 'c')
#
# (4, 400, 'd')
#
# (5, 500, 'e')
#
# Если вас не устраивают скобки, можете делать так:
#
# for i in zip(a, b, c): - обходим все элементы трех переменных
#
#          print(*i) – выводим их с приставкой ‘*’ чтобы не было скобок
#
# Чтобы из zip обьекта снова вернуть наши былые списки или кортежи делаем так:
#
# result = zip(a,b,c) -  записываем в оператор result zip обьект
#
# a1, b1, c1 = zip(*rezult) – записываем в три переменные элементы оператора result в котором хранится Zip object, * там берет элементы стоящие под первым индексом и кладет их по одному в три оператора и так делает до последнего индекса.
#
# print(a1, b1, c1) -  в трех переменных готовые списки которые соответствуют спискам изначальным.


# Пример создания словаря

keys = ['Ten', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'One hundred']
values = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
result = dict(zip(keys,values))
print(result)



# Еще один пример с сортировкой и созданием словаря
employees = [
    'Pankratiy', 'Innokentiy', 'Anfisa', 'Yaroslava', 'Veniamin',
    'Leonti', 'Daniil', 'Mishka', 'Lidochka',
    'Terenti', 'Vladik', 'Svetka', 'Maks', 'Yura', 'Sergei'
]

identifiers = [77, 48, 88, 85, 76, 81, 62, 43, 5, 56, 17, 20, 37, 32, 96]

employees = sorted(employees)
identifiers = sorted(identifiers)

employees_data = dict(zip(identifiers,employees))

